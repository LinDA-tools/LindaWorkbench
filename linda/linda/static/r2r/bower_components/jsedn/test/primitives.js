// Generated by CoffeeScript 1.8.0
(function() {
  var assert, assertEncode, assertNotParse, assertParse, edn, isNotVal, isVal, totalString, us, _ref;

  edn = require("../src/reader");

  us = require("underscore");

  _ref = require("./assertion"), isVal = _ref.isVal, isNotVal = _ref.isNotVal, assert = _ref.assert, assertParse = _ref.assertParse, assertNotParse = _ref.assertNotParse, assertEncode = _ref.assertEncode, totalString = _ref.totalString;

  assertParse("nil should be null", "nil", null);

  assertParse("nil should not match nilnil", "nilnil", isNotVal(null));

  assertParse("true should be true", "true", true);

  assertParse("false should be false", "false", false);

  assertParse("truefalse should not be true", "truefalse", isNotVal(true));

  assertParse("+ by itself is a valid symbol atom", "+", edn.sym("+"));

  assertParse('a "string like this" should be "string like this"', '"a string like this"', "a string like this");

  assertParse('a string "nil" should not be null', '"nil"', isNotVal(null));

  assertParse('a string should handle escaped quote chars', '"this is a string \\"and this should be escaped\\" mid string"', 'this is a string \"and this should be escaped\" mid string');

  assertParse('a string can contain escaped backslash itself', '"this is a string with \\\\ a backslash escaped"', 'this is a string with \\ a backslash escaped');

  assertParse('basic \\c characters should be string', '\\c', edn.char("c", "second arg"));

  assertParse('\\tab is a tab', '\\tab', edn.char("tab"));

  assertParse('\\newline is a newline', '\\newline', edn.char("newline"));

  assertParse('\\space is a space', '\\space', edn.char("space"));

  assertParse("can read escaped paren", "\\)", edn.char(")"));

  assertNotParse("do not allow symbols to start with ~", "~cat");

  assertNotParse("do not allow symbols to start with @", "@cat");

  assertNotParse("do not allow non-numeric starting character", "0xy");

  assertParse("basic symbol 'cat' should be 'cat'", 'cat', edn.sym('cat'));

  assertParse("symbol with special characters 'cat*rat-bat'", 'cat*rat-bat', edn.sym('cat*rat-bat'));

  assertParse("symbol with colon and hash in middle 'cat:rat#bat'", 'cat:rat#bat', edn.sym('cat:rat#bat'));

  assertParse("symbol can start with ?", "?x", edn.sym("?x"));

  assertParse("keyword starts with colon :fred is edn.Keyword :fred", ':fred', edn.kw(':fred'));

  assertParse("keyword can have slash :community/name", ':community/name', edn.kw(':community/name'));

  assertParse("0 is 0", '0', 0);

  assertParse("-0 is 0", "-0", 0);

  assertParse("9923 is 9923", '9923', 9923);

  assertParse("-9923 is -9923", '-9923', -9923);

  assertParse("+9923 is 9923", '+9923', 9923);

  assertParse("N for aritrary precision", "432N", 432);

  assertParse("Very big ints remain as strings which user can deal with how they please", "191561942608236107294793378084303638130997321548169216", edn.bigInt("191561942608236107294793378084303638130997321548169216"));

  assertParse("12.32 is 12.32", '12.32', 12.32);

  assertParse("-12.32 is -12.32", '-12.32', -12.32);

  assertParse("+9923.23 is 9923.23", "+9923.23", 9923.23);

  assertParse("M suffix on float", "223.230M", 223.230);

  assertParse("E+ supported for float", "45.4E+43M", 4.54e+44);

  assertParse("e+ supported for float", "45.4e+43M", 4.54e+44);

  assertParse("e+ supported for float no decimal", "45e+43", 4.5e44);

  assertParse("basic list (a b 42) works", '(a b 42)', new edn.List([edn.sym('a'), edn.sym('b'), 42]));

  assertParse("nested list (a (b 42 (c d)))", '(a (b 42 (c d)))', new edn.List([edn.sym('a'), new edn.List([edn.sym('b'), 42, new edn.List([edn.sym('c'), edn.sym('d')])])]));

  assertParse("vector works [a b c]", '[a b c]', new edn.Vector([edn.sym('a'), edn.sym('b'), edn.sym('c')]));

  assertParse("kv pairs in map work {:a 1 :b 2}", '{:a 1 :b 2}', new edn.Map([edn.kw(":a"), 1, edn.kw(":b"), 2]));

  assertParse("anything can be a key", '{[1 2 3] "some numbers"}', new edn.Map([new edn.Vector([1, 2, 3]), "some numbers"]));

  assertParse("even a map can be a key", '{{:name "blue" :type "color"} [ocean sky moon]}', new edn.Map([new edn.Map([edn.kw(":name"), "blue", edn.kw(":type"), "color"]), new edn.Vector([edn.sym("ocean"), edn.sym("sky"), edn.sym("moon")])]));

  assertParse("basic set \#{1 2 3}", '\#{1 2 3}', new edn.Set([1, 2, 3]));

  assertParse("a set is distinct", '\#{1 1 2 3}', 'set not distinct');

  assertParse("inst is handled by default", '#inst "1985-04-12T23:20:50.52Z"', new Date(Date.parse("1985-04-12T23:20:50.52Z")));

  assertParse('basic tags work #myapp/Person {:first "Fred" :last "Mertz"}', '#myapp/Person {:first "Fred" :last "Mertz"}', new edn.Tagged(new edn.Tag("myapp", "Person"), new edn.Map([edn.kw(":first"), "Fred", edn.kw(":last"), "Mertz"])));

  assertParse("unhandled tagged pair works", '#some/inst "1985-04-12T23:20:50.52Z"', new edn.Tagged(new edn.Tag("some", "inst"), "1985-04-12T23:20:50.52Z"));

  assertParse("tagged elements in a vector", "[a b #animal/cat rodger c d]", new edn.Vector([edn.sym("a"), edn.sym("b"), new edn.Tagged(new edn.Tag("animal", "cat"), edn.sym("rodger")), edn.sym("c"), edn.sym("d")]));

  edn.setTagAction(new edn.Tag("myApp", "Person"), function(obj) {
    return obj.set(edn.kw(":age"), obj.at(edn.kw(":age")) + 100);
  });

  assertParse("tag actions are recognized", "#myApp/Person {:name :walter :age 500}", new edn.Map([edn.kw(":name"), edn.kw(":walter"), edn.kw(":age"), 600]));

  assertParse("there can be comments in a vector", "[valid vector\n;;comment in vector\nmore vector items]", new edn.Vector([edn.sym("valid"), edn.sym("vector"), edn.sym("more"), edn.sym("vector"), edn.sym("items")]));

  assertParse("there can be inline comments", "[valid ;comment\n more items]", new edn.Vector([edn.sym("valid"), edn.sym("more"), edn.sym("items")]));

  assertParse("whitespace does not affect comments", "[valid;touching trailing comment\nmore items]", new edn.Vector([edn.sym("valid"), edn.sym("more"), edn.sym("items")]));

  assertParse("discarding item in vector", "[a b #_ c d]", new edn.Vector([edn.sym("a"), edn.sym("b"), edn.sym("d")]));

  assertParse("discard an item outside of form", "#_ a", "");

  assertParse("discard touches an item", "[a b #_c d]", new edn.Vector([edn.sym("a"), edn.sym("b"), edn.sym("d")]));

  assertParse("discard an entire form", "[a b #_ [a b] c d]", new edn.Vector([edn.sym("a"), edn.sym("b"), edn.sym("c"), edn.sym("d")]));

  assertParse("discard with a comment", "[a #_ ;we are discarding what comes next\n c d]", new edn.Vector([edn.sym("a"), edn.sym("d")]));

  assertParse("no one cares about commas", "[a ,,,,,, b,,,,,c ,d]", new edn.Vector([edn.sym("a"), edn.sym("b"), edn.sym("c"), edn.sym("d")]));

  assertParse("can lookup key", "{:a 1 :b 2}", function(m) {
    return m.at(edn.kw(':a')) === 1;
  });

  assertParse("can lookup by other object", '{[1 2] "rabbit moon"}', function(m) {
    return m.at(new edn.Vector([1, 2])) === "rabbit moon";
  });

  assertEncode("can encode basic map", {
    a: 1,
    b: 2
  }, "{\"a\" 1 \"b\" 2}");


  /*
  This can not work from a js obj a keys are coerced to strings regardless of your intention
  If a user wants numeric keys they need to use an edn.Map directly. 
  assertEncode "can encode map with numeric keys",
  	{1: 1, 200: 2}
  	"{1 1 200 2}"
   */

  assertEncode("can encode a list", [1, 2, 3], "[1 2 3]");

  assertEncode("can encode single element list", [1], "[1]");

  assertEncode("Can encode nil in hash map", new edn.Map([edn.kw(":x"), 1, edn.kw(":y"), null]), "{:x 1 :y nil}");

  assertEncode("can encode a nested list", [1, 2, 3, [4, 5, 6, [7, 8, 9, [10]]]], "[1 2 3 [4 5 6 [7 8 9 [10]]]]");

  assertEncode("can encode list of strings", ["a", "b", "c", "words that are strings"], "[\"a\" \"b\" \"c\" \"words that are strings\"]");

  assertEncode("can encode list of maps", [
    {
      name: "walter",
      age: 30
    }, {
      name: "tony",
      age: 50,
      kids: ["a", "b", "c"]
    }
  ], "[{\"name\" \"walter\" \"age\" 30} {\"name\" \"tony\" \"age\" 50 \"kids\" [\"a\" \"b\" \"c\"]}]");

  assertEncode("can encode tagged items", new edn.Tagged(new edn.Tag('myApp', 'Person'), {
    name: "walter",
    age: 30
  }), "#myApp/Person {\"name\" \"walter\" \"age\" 30}");

  assertEncode("can handle string that start with colon", new edn.Vector([':a', 'b']), "[\":a\" \"b\"]");

  assertParse("can parse and look up nested item", "{:cat [{:hair :orange}]}", function(r) {
    return edn.atPath(r, ":cat 0 :hair") === (edn.kw(":orange"));
  });

  assertParse("can handle vector of symbols starting with ?", "[?x ?y ?z]", new edn.Vector([edn.sym("?x"), edn.sym("?y"), edn.sym("?z")]));

  assertEncode("can handle question marks for keywords", [edn.kw(":find"), edn.sym("?m"), edn.kw(":where"), [edn.sym("?m"), edn.kw(":movie/title")]], "[:find ?m :where [?m :movie/title]]");

  assertEncode("can handle bare _ as symbol", [edn.sym("_"), edn.kw(":likes"), edn.sym("?x")], "[_ :likes ?x]");

  assertEncode("can handle null", null, "nil");

  assertParse("reading files works as expected", edn.encode(edn.readFileSync("" + __dirname + "/test.edn")), new edn.Map([edn.kw(":key"), "val", edn.kw(":key2"), new edn.Vector([1, 2, 3])]));

  assertEncode("do not coerce numeric strings into numbers", {
    a: "1"
  }, "{\"a\" \"1\"}");

  assertEncode("encoding stringified json string handles quoting correctly", edn.encode(JSON.stringify({
    a: "1"
  })), '"\\\"{\\\\"a\\\\":\\\\"1\\\\"}\\\""');

  assert("json decoding an encoded json stringifed object...", JSON.parse(edn.parse(edn.encode(JSON.stringify({
    a: "1"
  })))), {
    a: "1"
  });

  assert("two keywords are eqaul", (edn.kw(":cat")) === (edn.kw(":cat")), true);

  assert("toJS works with nil as null", edn.toJS(edn.parse("nil")), null);

  assert("vector should handle nil", edn.toJS(edn.parse("[nil nil nil]")), [null, null, null]);

  assert("map should handle nil values", edn.toJS(edn.parse("{x nil nil nil}")), (function() {
    var x;
    x = {
      x: null
    };
    x[null] = null;
    return x;
  })());

  console.log(totalString());

}).call(this);
